<!DOCTYPE html>
<html>

<head>
    <title>LABOS 3 - HTML5</title>
    <style>
        canvas {
            border: 1px solid #000000;
            background-color: #FFFFFFFF;
        }
    </style>
    <script>
        let player = null;

        let canvasHeight = window.innerHeight;
        let canvasWidth = window.innerWidth;
        //web stranica nemre registrirati vise keydownova ili keyupova odjednom pa se koristi ova struktura kako bi se 
        //znalo koji su keyevi trenutno pritisnuti
        //https://stackoverflow.com/questions/5203407/how-to-detect-if-multiple-keys-are-pressed-at-once-using-javascript
        let pressedKeys = {};

        let spawnedAsteroids = [];
        //maksimalan broj asteroida koji trebaju biti aktivni u nekom trenutku;
        let spawnAmount = 7;
        //najmanji broj vidljivih asteroida - ukoliko ih je manje od toga, trebaju se spawnati novi
        let minimalAsteroidCount = 5;
        let maxAsteroidSpeed = 10;
        let currentAsteroid = null;

        let gameStart = null;
        let gameEnd = null;

        function startGame() {
            let centerWidth = canvasWidth / 2;
            let centerHeight = canvasHeight / 2;
            player = new component(35, 35, "#FF0000", centerWidth, centerHeight, "player");
            //https://css-tricks.com/snippets/javascript/random-hex-color/
            //generiranje random boje
            for (let i = 0; i < spawnAmount; i++) {
                spawnedAsteroids.push(new component(40, 40, generateGrayColor(), canvasWidth, canvasHeight, "asteroid"));
            }
            gameStart = new Date().getTime();
            myGameArea.start();
        }

        //https://stackoverflow.com/questions/22692588/random-hex-generator-only-grey-colors
        function generateGrayColor() {
            var value = Math.random() * 0xFF | 0;
            var grayscale = (value << 16) | (value << 8) | value;
            return '#' + grayscale.toString(16);
        }
        var myGameArea = {
            canvas: document.createElement("canvas"),
            start: function () {
                this.canvas.id = "myGameCanvas";
                this.canvas.width = canvasWidth * 0.99;
                this.canvas.height = canvasHeight * 0.975;
                this.context = this.canvas.getContext("2d");
                document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                this.frameNo = 0;
                this.interval = setInterval(updateGameArea, 20);
            },
            stop: function () {
                clearInterval(this.interval);
                let finalScore = gameEnd - gameStart;
                let highScore = parseFloat(localStorage.getItem("highscore")) || 0;

                //console.log("FINAL SCORE: ", finalScore);
                //console.log("HIGHSCORE: ", highScore);
                if (finalScore > highScore) {
                    localStorage.setItem("highscore", finalScore);
                }
            },
            clear: function () {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            },

            showScore: function () {
                this.context.font = "25px Arial";
                this.context.fillStyle = "#0000000";
                this.context.fillText("Najbolje vrijeme: " + (formatScore(parseFloat(localStorage.getItem("highscore"))) || "00:00.00"), canvasWidth - 0.25 * canvasWidth, canvasHeight - (canvasHeight - 20));
                this.context.fillText("Vrijeme: " + getCurrentTimeScore(), canvasWidth - 0.25 * canvasWidth, canvasHeight - (canvasHeight - 50));
            }

        }

        //https://stackoverflow.com/questions/33458174/get-current-datetime-in-minutes-and-convert-datetime-d-m-y-hm-to-minutes-java
        function getCurrentTimeScore() {
            let currentTime = new Date().getTime() - gameStart;
            //console.log("CURRENT TIME: " + currentTime);
            let minutes = Math.floor(currentTime / (1000 * 60));
            //console.log("MINUTES: ",minutes);
            currentTime -= minutes * 1000 * 60;
            let seconds = Math.floor(currentTime / 1000);
            currentTime -= seconds * 1000;
            let miliseconds = currentTime;

            return `${minutes}:${seconds}.${miliseconds}`;
        }

        function formatScore(timeScore) {
            //console.log("CURRENT TIME: " + currentTime);
            let minutes = Math.floor(timeScore / (1000 * 60));
            //console.log("MINUTES: ",minutes);
            timeScore -= minutes * 1000 * 60;
            let seconds = Math.floor(timeScore / 1000);
            timeScore -= seconds * 1000;
            let miliseconds = timeScore;

            return `${minutes}:${seconds}.${miliseconds}`;
        }
        function component(width, height, color, x, y, type) {
            this.type = type;
            this.width = width;
            this.height = height;

            if (this.type === "player") {
                this.speed_x = 5;
                this.speed_y = 5;
                this.x = x;
                this.y = y;
            }

            else {
                //rezultat ovog izraza je brzina u rasponu [-maxAsteroidSpeed / 2, maxAsteroidSpeed / 2]
                this.speed_x = Math.floor(Math.random() * maxAsteroidSpeed) - maxAsteroidSpeed / 2;
                this.speed_y = Math.floor(Math.random() * maxAsteroidSpeed) - maxAsteroidSpeed / 2;

                //console.log(`SPEED: (${this.speed_x}, ${this.speed_y})`);
                let spawnOffset = Math.random() * 20;
                this.distanceTraveled = - spawnOffset;
                if (this.speed_x > 0) {
                    this.x = 0 - spawnOffset;
                }
                else {
                    this.x = canvasWidth + spawnOffset;
                }
                if (this.speed_y > 0) {
                    this.y = 0 - spawnOffset;
                }
                else {
                    this.y = canvasHeight + spawnOffset;
                }
            }

            //console.log(`lower border: ${this.lowerBorder}, upper border: ${this.upperBorder}`);
            //console.log("GENERATED OBJECT");
            this.update = function () {
                ctx = myGameArea.context;
                ctx.save();
                ctx.shadowColor = "black";
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
                ctx.translate(this.x, this.y);
                ctx.fillStyle = color;
                ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
                ctx.restore();

                this.leftBorder = this.x - this.width / 2;
                this.rightBorder = this.x + this.width / 2;
                this.lowerBorder = this.y - this.height / 2;
                this.upperBorder = this.y + this.height / 2;
            }
            this.movePlayer = function () {
                if (pressedKeys[37] == true) {
                    direction_x = -1;
                }
                else if (pressedKeys[39] == true) {
                    direction_x = 1;
                }
                else {
                    direction_x = 0;
                }

                if (pressedKeys[38] == true) {
                    direction_y = -1;
                }
                else if (pressedKeys[40] == true) {
                    direction_y = 1;
                }
                else {
                    direction_y = 0;
                }
                this.x += direction_x * this.speed_x;
                this.y += direction_y * this.speed_y;

                //horizontalni teleport
                if (this.x + this.width >= canvasWidth && direction_x === 1) {
                    this.x = 0;
                }
                else if (this.x < 0) {
                    this.x = canvasWidth;
                }

                //vertikalni teleport
                if (this.y + this.height <= 0 && direction_y === -1) {
                    this.y = canvasHeight;
                }
                else if (this.y > canvasHeight) {
                    this.y = 0;
                }
            }
            this.moveAsteroid = function () {
                //console.log(`ASTEROID POSITION: (${this.x}, ${this.y})`);
                this.x += this.speed_x;
                this.y += this.speed_y;
                this.distanceTraveled += Math.sqrt(Math.pow(this.x, 2), Math.pow(this.y, 2));
            }

            //provjerava je li asteroid vidljiv u canvasu, ako nije, brise se
            this.checkAsteroidCanvas = function (position) {
                if (this.distanceTraveled >= canvasWidth && (this.x < 0 || this.x > canvasWidth || this.y < 0 || this.y > canvasHeight)) {
                    spawnedAsteroids.splice(position, 1);
                }
            }
        }

        function handleAsteroidCount() {
            let activeAsteroids = spawnedAsteroids.length;
            if (activeAsteroids < minimalAsteroidCount) {
                for (let i = 0; i < spawnAmount - activeAsteroids; i++) {
                    spawnedAsteroids.push(new component(40, 40, generateGrayColor(), canvasWidth, canvasHeight, "asteroid"));
                }
            }
        }

        function checkColission(asteroid) {
            //https://stackoverflow.com/questions/31022269/collision-detection-between-two-rectangles-in-java
            if (player.rightBorder >= asteroid.leftBorder &&
                player.leftBorder <= asteroid.rightBorder &&
                player.upperBorder >= asteroid.lowerBorder &&
                player.lowerBorder <= asteroid.upperBorder) {
                return true;
            }
            return false;
        }
        function updateGameArea() {
            myGameArea.clear();
            myGameArea.showScore();
            player.movePlayer();
            player.update();
            for (let asteroidPos in spawnedAsteroids) {
                currentAsteroid = spawnedAsteroids[asteroidPos];
                currentAsteroid.moveAsteroid();
                currentAsteroid.update();
                if (checkColission(currentAsteroid)) {
                    gameEnd = new Date().getTime();
                    myGameArea.stop();
                    //console.log("DURATION: ", gameEnd - gameStart);
                }
                currentAsteroid.checkAsteroidCanvas(asteroidPos);
            }
            handleAsteroidCount();
        }

        window.addEventListener('keydown', function (event) {
            const key = event.keyCode;
            pressedKeys[key] = true;
        });
        window.addEventListener('keyup', function (event) {
            const key = event.keyCode;
            pressedKeys[key] = false;
        });
    </script>
</head>

<body onload="startGame()">
</body>

</html>